/*******************************************************************************
 * Copyright (c) 2010-2019 Haifeng Li
 *
 * Smile is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * Smile is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Smile.  If not, see <https://www.gnu.org/licenses/>.
 *******************************************************************************/

package smile.neighbor;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.nio.ByteBuffer;
import java.util.*;

import smile.hash.MurmurHash2;
import smile.math.distance.HammingDistance;
import smile.sort.HeapSelect;
import smile.util.IntArrayList;

/**
 * Locality-Sensitive Hashing for Signatures.
 * LSH is an efficient algorithm for approximate nearest neighbor search
 * in high dimensional spaces by performing probabilistic dimension reduction of data.
 * The basic idea is to hash the input items so that similar items are mapped to the same
 * buckets with high probability (the number of buckets being much smaller
 * than the universe of possible input items).
 * To avoid computing the similarity of every pair of sets or their signatures.
 * If we are given signatures for the sets, we may divide them into bands, and only
 * measure the similarity of a pair of sets if they are identical in at least one band.
 * By choosing the size of bands appropriately, we can eliminate from
 * consideration most of the pairs that do not meet our threshold of similarity.
 * <p>
 * By default, the query object (reference equality) is excluded from the neighborhood.
 * Note that you may observe weird behavior with String objects. JVM will pool the string
 * literal objects. So the below variables
 * <code>
 *     String a = "ABC";
 *     String b = "ABC";
 *     String c = "AB" + "C";
 * </code>
 * are actually equal in reference test <code>a == b == c</code>. With toy data that you
 * type explicitly in the code, this will cause problems. Fortunately, the data would be
 * read from secondary storage in production.
 * </p>
 *
 * <h2>References</h2>
 * <ol>
 * <li>Moses S. Charikar. Similarity Estimation Techniques from Rounding Algorithms</li>
 * </ol>
 *
 * @see LSH
 * @author Qiyang Zuo
 */
public class SNLSH<E> implements NearestNeighborSearch<String[], E>, KNNSearch<String[], E>, RNNSearch<String[], E>, Serializable {
    private static final long serialVersionUID = 1L;

    /** Hash function mask. */
    private final long mask;
    /** The number of bits of hash function. */
    private static final int BITS = 64;
    /**
     * Signature fractions
     */
    private LinkedHashMap<Long, IntArrayList>[] bands;
    /**
     * The data objects.
     */
    private List<E> data = new ArrayList<>();
    /**
     * The keys of data objects.
     */
    private List<String[]> keys = new ArrayList<>();
    /**
     * signatures generated by simhash
     */
    private List<Long> signatures = new ArrayList<>();

    /**
     * Constructor.
     * @param L the number of bands/hash tables.
     */
    @SuppressWarnings("unchecked")
    public SNLSH(int L) {
        if (L < 2 || L > 32) {
            throw new IllegalArgumentException("Invalid band size!");
        }

        bands = (LinkedHashMap<Long, IntArrayList>[]) Array.newInstance(LinkedHashMap.class, L);
        for (int i = 0; i < L; i++) {
            bands[i] = new LinkedHashMap<>();
        }
        mask = -1 >>> (BITS / L * (L - 1));
    }

    /** Adds a new item. */
    public void put(String[] sentence, E v) {
        int index = data.size();
        keys.add(sentence);
        data.add(v);

        long signature = simhash64(sentence);
        signatures.add(signature);

        for (int i = 0; i < bands.length; i++) {
            long bandKey = bandHash(signature, i);
            IntArrayList bucket = bands[i].get(bandKey);
            if (bucket == null) {
                bucket = new IntArrayList();
            }
            bucket.add(index);
            bands[i].put(bandKey, bucket);
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public Neighbor<String[], E>[] knn(String[] q, int k) {
        if(k < 1) {
            throw new IllegalArgumentException("Invalid k: " + k);
        }

        long fpq = simhash64(q);
        Set<Integer> candidates = getCandidates(q);
        k = Math.min(k, candidates.size());

        HeapSelect<Neighbor<String[], E>> heap = new HeapSelect<>(new Neighbor[k]);
        for (int index : candidates) {
            long sign = signatures.get(index);
            double distance = HammingDistance.d(fpq, sign);
            heap.add(new Neighbor<>(keys.get(index), data.get(index), index, distance));
        }

        heap.sort();
        return heap.toArray();
    }

    @Override
    public Neighbor<String[], E> nearest(String[] q) {
        Neighbor<String[], E>[] ns = knn(q, 1);
        if (ns.length > 0) {
            return ns[0];
        }

        return null;
    }

    @Override
    public void range(String[] q, double radius, List<Neighbor<String[], E>> neighbors) {
        if (radius <= 0.0) {
            throw new IllegalArgumentException("Invalid radius: " + radius);
        }
        long fpq = simhash64(q);
        Set<Integer> candidates = getCandidates(q);
        for (int index : candidates) {
            int distance = HammingDistance.d(fpq, signatures.get(index));
            if (distance <= radius) {
                neighbors.add(new Neighbor<>(keys.get(index), data.get(index), index, distance));
            }
        }
    }

    /**
     * Calculates the hash value for a band.
     */
    private long bandHash(long hash, int band) {
        return hash >>> ((band * (BITS / bands.length))) & mask;
    }

    /** Returns the nearest neighbor candidates. */
    private Set<Integer> getCandidates(String[] q) {
        Set<Integer> candidates = new LinkedHashSet<>();
        long sign = simhash64(q);
        for (int i = 0; i < bands.length; i++) {
            long bandKey = bandHash(sign, i);
            IntArrayList bucket = bands[i].get(bandKey);
            if (bucket != null) {
                for (int j = 0; j < bucket.size(); j++) {
                    candidates.add(bucket.get(j));
                }
            }
        }
        return candidates;
    }

    /** Calculates the 64-bit hash of string tokens. */
    private long simhash64(String[] tokens) {
        final long seed = 0; //do not change seed

        int[] bits = new int[BITS];
        for (String s : tokens) {
            ByteBuffer buffer = ByteBuffer.wrap(s.getBytes());
            long hc = MurmurHash2.hash64(buffer, 0, buffer.array().length, seed);
            for (int i = 0; i < BITS; i++) {
                if (((hc >>> i) & 1) == 1) {
                    bits[i]++;
                } else {
                    bits[i]--;
                }
            }
        }

        long hash = 0;
        long one = 1;
        for (int i = 0; i < BITS; i++) {
            if (bits[i] >= 0) {
                hash |= one;
            }
            one <<= 1;
        }
        return hash;
    }
}
